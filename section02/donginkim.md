# Section 2. 웹 서버와 서블릿 컨테이너

## 웹 서버와 스프링 부트 소개

**전통적인 방식**

- 서버에 톰캣 등의 WAS(웹 애플리케이션 서버)를 설치
- WAS에서 동작하도록 서블릿 스펙에 맞춰 코드를 작성
- WAR 형식으로 빌드해서 war 파일 생성
- war 파일을 WAS에 전달해서 배포하는 방식

*WAS와 연동해서 실행되도록 복잡한 추가 설정이 필요

**최근 방식**

- 스프링 부트가 내장 톰캣 포함
- 애플리케이션 코드 안에 톰캣 같은 WAS가 라이브러리로 내장
- 코드를 작성하고 JAR로 빌드한 다음 JAR를 원하는 위치에 실행하기만 하면 WAS도 함께 실행
- 개발자는 main() 메서드만 실행하면 되고 WAS 설치나 IDE와 WAS를 연동하는 복잡한 일을 수행하지 않아도 된다.

## JAR, WAR 간단 소개

**JAR 소개**

- 자바는 여러 클래스와 리소스를 묶어 JAR(Java Archive)라고 하는 압축파일을 만들 수 있다.
- 이 팔일은 JVM 위에서 직접 실행되거나 다른 곳에서 사용하는 라이브러리가 된다.
- 직접 실행하는 경우 `main()` 메서드가 필요하고 `MANIFEST.MF` 파일에 실행할 메인 메서드가 있는 클래스를 지정해두어야 한다.

`java -jar abc.jar`

- Jar는 쉽게 이야기해서 클래스와 관련 리소스를 압축한 단순한 파일이다. 필요한 경우 이 파일을 직접 실행할 수 있고 다른 곳에서 라이브러리로 사용할 수 있다.

**WAR 소개**

- WAR(Web Application Archive)는 웹 애플리케이션 서버에 배포할 때 사용하는 파일이다.
- JAR는 JVM 위에서 실행, WAR는 웹 애플리케이션 서버 위에서 실행된다.
- HTML 같은 정적 리소스와 클래스 파일을 모두 함께 포함하기 때문에 JAR와 비교해서 구조가 더 복잡하다.
- 또한 WAR 구조를 지켜야 한다.

WAR 구조

- WEB-INF
    - `classes`: 실행 클래스 모음
    - `lib`: 라이브러리 모음
    - `web.xml` 웹 서버 배치 설정 파일(생략 가능)
- `index.html` 정적 리소스

- `WEB-INF` 폴더 하위는 자바 클래스와 라이브러리, 설정 정보가 들어가는 곳이다.
- `WEB-INF`를 제외한 나머지 영역은 HTML, CSS 같은 정적 리소스가 사용되는 영역이다.


## 서블릿 컨테이너 초기화

- WAS를 실행하는 시점에 초기화 작업이 필요하다.
    - 필터와 서블릿 등록
    - 스프링 컨테이너 생성
    - 서블릿과 스프링을 연결하는 디스패처 서블릿 등록
- WAS가 제공하는 초기화 기능 사용
- WAS 실행 시점에 초기화 과정 진행
- 과거에는 web.xml 을 사용해서 초기화 했지만 지금은 서블릿 스펙에서 자바 코드를 사용한 초기화도 같이 지원

서블릿을 등록하는 2가지 방법

- `@WebServlet` 애노테이션
- 프로그래밍 방식

애플리케이션 초기화

- 서블릿 컨테이너는 조금 더 유연한 초기화 기능을 지원
- 애플리케이션 초기화라고 하려고 한다.

서블릿 등록시 프로그래밍 방식을 사용하는 이유

- `@WebServlet` 애노테이션 하나로 서블릿을 편리하게 등록할 수 있다.
- 하지만 애노테이션 방식은 유연하게 변경이 어렵다.
- 가령 `@WebServlet` 은 정해진 프로퍼티에 url을 직접 넣어야지만 프로그래밍 방식은 여러 방법으로 넣어줄 수  있다. 또한 분기처리도 가능하다.

참고

왜 복잡한 애플리케이션 초기화라는 개념이 만들어졌을까?

**편리함**

- 서블릿 컨테이너를 초기화하려면 `ServletContainerInitializer` 인터페이스를 구현한 코드를 만들어야 한다. 추가로 `META-INF/services/jakarta.servlet.ServletContainerInitializer` 파일에 해당 코드를 직접 지정해야한다.
- 애플리케이션 초기화는 특정 인터페이스만 구현하면 된다.

**의존성**

- 애플리케이션 초기화는 서블릿 컨테이너에 상관없이 원하는 모양으로 인터페이스를 만들 수 있다. 이를 통해 애플리케이션 초기화 코드가 서블릿 컨테이너에 대한 의존을 줄일 수 있다.  특히 ServletContext ctx 가 필요없는 애플리케이션 초기화 코드라면 의존을 완전히 제거할 수도 있다.

## 스프링 컨테이너 등록

- WAS와 스프링 컨테이너 통합
- 서블리 컨테이너 초기화와 애플리케이션 초기화 활용

- 스프링 컨테이너 만들기
- 스프링 MVC 컨트롤러를 스프링 컨테이너에 빈으로 등록
- 스프링 MVC를 사용하는데 필요한 디스패처 서블릿을 서블릿 컨테이너 등록

## 스프링 MVC 서블릿 컨테이너 초기화 지원

서블릿 컨테이너를 초기화하기 위해 강의에서는 다양하고 복잡한 과정을 진행
1. `ServletContainerInitializer` 인터페이스 구현한 서블릿 컨테이너 객체 생성 그 안에서 서블릿 초기화 코드 구현
3. `@HandlesTypes` 로 애플리케이션 초기화 작업할 인터페이스 명시
4. 위에서 등록한 인터페이스의 구현체 작성
5. `META-INF/services/{패키지 경로 + 서블릿 컨테이너 구현체} 등록
6. 서버 기동시 초기화 작업 인터페이스를 구현한 객체들을 각각 실행
7. 구현체를 늘리기만하면 확장에 열려있는 구조


### 스프링 MVC가 제공하는 서블릿 컨테이너 초기화 분석

- `WebApplicationInitializer` 인터페이스 하나로 애플리케이션 초기화가 가능한 이유가 뭘까?

1. spring-web 라이브러의 META-INF/services 디렉토리에 `SpringServletContainerInitializer` 등록
2. `SpringServletContainerInitializer` 클래스 위에 `@HandlesTypes(WebApplicationInitializer.class)` 기재
3. onStartup 메서드 구현부에 webAppInitializerClasses 인터페이스를 구현한 구현체들을 리플렉션으로 생성한 뒤 각각 실행

# 생각해보기
- 서블릿 컨테이너 초기화 작업이 실제 어떤 종류가 있는지?
- 애플리케이션 초기화 작업이 실제 어떤 종류가 있는지?
- 스프링 컨테이너의 초기화 작업은 순서가 정해져 있는지?
- 스프링 컨테이너가 생성된 이후의 작업도 이것과 연관이 있는지?
